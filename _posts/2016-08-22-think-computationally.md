---
layout: post
title: Think Computationally
date: 2016-08-22
tags:
- computer science
- mentoring
---
A huge gulf exists between dabbling with code and really getting at the heart of a problem using dedicated computational thinking. This gap marks the main difference between the beginner and advanced learner of code. <!-- more -->

## Well, what is it?
Computational thinking is the often overlooked but vastly important ability to see beyond individual tools such as frameworks, editors, even programming languages. It entails understanding how to go about logically resolving a specific problem in a progressive and incremental manner much as a computer does.

Breaking down problems like this is second nature to long time programmers, and in my humble opinion it is one of the most important skills to learn as a beginning learner of code. 

Realizing the importance of how to go about thinking computationally was a great leap forward in my coding education and opened the door to more advanced computer science concepts such as algorithm efficiency, Big O notation, and understanding how to RTFEM[^fn-1]. 

## OK, but how do I think computationally?
I can attempt to relate computational thinking to physics (putting my Uni degree to work!) There is a method called the free body diagram[^fn-2], which shows a body, (whatever the subject of the particular problem,) being worked upon by all external and internal forces. The purpose of the diagram is to  illustrate and calculate what will happen to the body given a set of known circumstances. 

Similarly, in computer science we can think of the program as our body, and the environment/system as external forces. If we visualize all the external and internal forces on our 'body', then we are better equipped to predict  future reactions. More importantly, we can more quickly find and explain errors when our predictions fall short. 

This to me is the essence of computational thinking, an almost Zen-like philosophical approach to programming, which does much to explain the benevolent stereotype of the wise UNIX sysadmin for whom no error message is entirely inscrutable. 

You know the type: after struggling with a certain problem for a while you seek the guru's advice. With a simple hand wave over the keyboard and a twinkle in their eye, they make the problem **disappear**. 

This is computational thinking in action. Much like a good magic trick, there is nothing mystical happening but the combined power of great experience. The goal is to one day also achieve such a level of mastery that makes debugging look like magic. 

## So I should "Be one with the machine". Got it.
Computational thinking can be seen in a pristine form when we take a look at the basic rules of the UNIX philosophy[^fn-3]. I won't go into too much detail right now on each rule; suffice to say this reading material should be required for anyone who is starting to learn to code.  

If there seems to be a lot of Zen Buddhist philosophy wrapped up in many computer science concepts, specifically in programming, it is due to this tradition based in practice which has been passed down over decades.

These concepts are not so much rigid dogma as they are principles proven over time to facilitate the creation, communication, and maintenance of code. These concepts are not etched in stone; if any of the accepted statutes were to one day become inadequate, then it would be our duty as pragmatic programmers to revisit, modify or throw out the tenet if it no longer serves our need. 

The reason to be fluid is evident. We have seen paradigm shifts in the past, and we will continue to see them in the future. Machine Learning, AI, quantum computing and more new fields will require many of the same principles which have served us in the past, as well as introduce new methods. 

Computational thinking will continue to be valuable since it is such a fundamental way of how we program and solve problems using these marvelous devices called computers. 

[^fn-1]: [RTF Error Message, close relative to RTF Man Page](https://xkcd.com/293/ "xkcd webcomic")
[^fn-2]: [Free body diagram](https://en.wikipedia.org/wiki/Free_body_diagram "Wikipedia article")
[^fn-3]: [The Art of Unix Programming by Eric Steven Raymond](http://www.catb.org/esr/writings/taoup/html/ch01s06.html "online book")
